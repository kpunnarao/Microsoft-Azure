### **ðŸš€ Module 8.6: Azure DevOps for CI/CD of IaC & Applications**

To truly achieve operational excellence in the cloud, automation must extend beyond individual tasks to the entire software delivery lifecycle.

**Azure DevOps** provides a suite of integrated services that enable teams to plan, develop, test, and deploy applications and infrastructure continuously. 

At its core, Azure DevOps facilitates **Continuous Integration (CI)** and **Continuous Delivery/Deployment (CD)** through its robust **Azure Pipelines** service.

#### **I. What is Azure DevOps?**

Azure DevOps is a collection of services that provides an end-to-end solution for software development, from planning and development to testing and deployment. It supports any language, platform, and cloud.

The main integrated services within Azure DevOps are:

1.  **Azure Boards:** Agile tools for planning, tracking, and managing work using Kanban boards, backlogs, sprints, and dashboards.
2.  **Azure Repos:** Provides Git repositories or Team Foundation Version Control (TFVC) for source code management, including features like branch policies and pull requests.
3.  **Azure Pipelines:** A highly flexible and scalable CI/CD service that automates the build, test, and deployment of code to any target. This is our primary focus for this module.
4.  **Azure Test Plans:** Tools for manual and exploratory testing, test case management, and integrating automated tests.
5.  **Azure Artifacts:** A package management service for creating, hosting, and sharing various package types (NuGet, npm, Maven, Python, etc.) within your team or organization.

#### **II. Continuous Integration (CI) and Continuous Delivery/Deployment (CD)**

Azure Pipelines is the engine for CI/CD. Understanding these concepts is crucial:

**A. Continuous Integration (CI):**

  * **Definition:** A development practice where developers frequently integrate their code changes into a central repository (e.g., Git). Each integration is then verified by an automated build and automated tests.
  * **Goal:** To detect integration errors as early as possible.
  * **How Azure Pipelines facilitates CI:**
      * **Automated Triggers:** Pipelines automatically kick off (build, compile, run unit tests) on every code commit to a designated branch.
      * **Build Across Platforms:** Supports building projects in various languages (e.NET, Java, Node.js, Python) on different operating systems (Windows, Linux, macOS) using Microsoft-hosted or self-hosted agents.
      * **Automated Testing:** Integrates with testing frameworks to run unit, integration, and other automated tests, providing immediate feedback on code quality.
      * **Artifact Generation:** Produces deployable packages (artifacts) containing compiled code, infrastructure templates, and dependencies that can be consumed by subsequent CD pipelines.

**B. Continuous Delivery (CD) / Continuous Deployment (CD):**

  * **Continuous Delivery (CD):** A software engineering approach where code changes are automatically built, tested, and prepared for a release to production. It ensures that you can release new changes to your customers rapidly and reliably in a sustainable way. While deployments are automated, a *manual approval* or trigger is typically required for the final production deployment.
  * **Continuous Deployment (CD):** Takes Continuous Delivery a step further. After passing all automated tests and quality gates, the code is *automatically deployed* to production without human intervention. This requires a high degree of confidence in your automated testing and monitoring.
  * **How Azure Pipelines facilitates CD:**
      * **Automated Releases:** Automatically deploys the artifacts generated by the CI pipeline to one or more environments (dev, test, staging, production).
      * **Multi-Stage Pipelines:** Supports defining sequential stages (e.g., Build -\> Dev Deploy -\> Test -\> Staging Deploy -\> Prod Deploy) with conditions and approvals between stages.
      * **Deployment Gates & Approvals:** Allows for manual approvals, automated pre-deployment and post-deployment gates (e.g., checking Azure Monitor alerts, ticketing system status, external API calls) to ensure quality and control.
      * **Environment Management:** Provides an `Environments` feature to manage collections of resources where applications are deployed, enabling checks and approvals specific to an environment.

#### **III. Key Components of an Azure Pipeline**

Azure Pipelines are defined using YAML (preferred) or the Classic Editor (UI). Regardless of the authoring method, they follow a logical structure:

1.  **Pipeline:** The top-level definition of your CI/CD workflow.
2.  **Triggers:** Define what starts a pipeline run (e.g., `pr` for pull requests, `ci` for commits to specific branches, schedules, webhook events).
3.  **Stages:**
      * **Purpose:** A major logical division in a pipeline. Stages group related jobs and represent a significant phase in your CI/CD process (e.g., `Build`, `DeployToDev`, `DeployToProd`).
      * **Characteristics:** Stages run sequentially by default but can be configured with dependencies and conditions to control their execution flow. Each stage has one or more jobs.
4.  **Jobs:**
      * **Purpose:** A collection of steps that run sequentially on a single agent or a deployment group.
      * **Characteristics:** Jobs can run in parallel. A common pipeline might have a `Build Job` and multiple `Deployment Jobs` (one for each environment).
5.  **Steps:**
      * **Purpose:** The smallest building block of a job. Each step executes a task or a script.
      * **Types:**
          * **Tasks:** Pre-packaged scripts or actions provided by Azure DevOps or the Marketplace (e.g., `AzureResourceManagerTemplateDeployment@3`, `DotNetCoreCLI@2`, `PublishBuildArtifacts@1`).
          * **Scripts:** Inline PowerShell, Bash, or command-line scripts directly written in the YAML.
6.  **Agents:**
      * **Purpose:** The computing infrastructure where pipeline jobs run.
      * **Types:**
          * **Microsoft-hosted agents:** Cloud-based agents provided and managed by Microsoft, pre-installed with various tools and software. (e.g., `ubuntu-latest`, `windows-latest`).
          * **Self-hosted agents:** Agents that you install and manage on your own machines (on-premises, Azure VMs, other clouds). Useful for accessing private networks, using specific software, or running very large builds.

#### **IV. CI/CD for Infrastructure as Code (IaC) & Applications**

**A. CI/CD for IaC (e.g., Bicep/ARM Templates):**

1.  **CI Phase:**
      * **Trigger:** On every commit to your IaC repository (e.g., `main` branch, feature branches).
      * **Steps:**
          * **Restore Bicep Modules (if applicable):** `az bicep restore` for external modules.
          * **Linting/Validation:** Run Bicep linter (`az bicep build --no-restore`) to check for syntax errors and best practices.
          * **Pre-flight Validation:** Use `az deployment group validate` (or `Test-AzResourceGroupDeployment`) to ensure the template is valid against Azure APIs without deploying.
          * **What-If Analysis:** Execute `az deployment group what-if` to preview the changes the deployment would make. Store the output as an artifact or log.
          * **Publish Artifacts:** Publish the Bicep files (and transpiled ARM JSON if needed) as a pipeline artifact.
2.  **CD Phase:**
      * **Trigger:** Automatically after a successful CI build or via manual approval for specific environments.
      * **Steps:**
          * **Download Artifacts:** Retrieve the IaC artifacts from the build pipeline.
          * **Deployment:** Use `AzureResourceManagerTemplateDeployment@3` task (for ARM/Bicep) or `AzureCLI@2` / `AzurePowerShell@5` to execute the Bicep deployment.
          * **Parameter Management:** Pass environment-specific parameters to the deployment (e.g., from variable groups, pipeline variables).
          * **Post-Deployment Validation:** Run automated tests or configuration checks to ensure the deployed infrastructure is in the desired state.

**B. CI/CD for Applications:**

1.  **CI Phase (Build Pipeline):**
      * **Trigger:** On every code commit to the application's source repository.
      * **Steps:**
          * **Get Sources:** Clone the application code.
          * **Build:** Compile the application code (e.g., `dotnet build`, `npm install && npm build`, `mvn package`).
          * **Run Unit Tests:** Execute automated unit tests.
          * **Code Analysis:** Run static code analysis tools (e.g., SonarQube).
          * **Publish Artifacts:** Package the compiled application code, web deploy packages, Docker images, etc., as build artifacts.
2.  **CD Phase (Release Pipeline):**
      * **Trigger:** Automatically after a successful CI build, or on a schedule, or manually.
      * **Stages (typically Dev -\> Test -\> Staging -\> Prod):**
          * **Download Artifacts:** Retrieve the application artifact.
          * **Deploy to Environment:** Use relevant tasks to deploy the application (e.g., `AzureRmWebAppDeployment@4` for App Service, `KubernetesManifest@1` for AKS, `AzureFunctionApp@2` for Azure Functions).
          * **Configuration:** Apply environment-specific application settings (connection strings, API keys) often pulled from Key Vault (see below).
          * **Automated Tests:** Run integration tests, functional tests, performance tests, or security scans against the deployed application in each environment.
          * **Approvals/Gates:** Implement pre-deployment approvals (manual) or automated gates (e.g., query Azure Monitor for no critical errors, wait for external security scan results) before proceeding to the next stage.
          * **Monitoring Integration:** Configure monitoring and alerting for the deployed application.
          * **Rollback Strategy:** Plan for rollback mechanisms in case of deployment failures.

#### **V. Integrating with Azure Key Vault for Secrets Management**

Hardcoding secrets (passwords, API keys, connection strings) in pipelines is a major security risk. Azure Key Vault should be used to securely store secrets, and Azure DevOps pipelines can integrate with it:

1.  **Create an Azure Key Vault:** Store your secrets (e.g., database passwords, service principal secrets) in Key Vault.
2.  **Create a Service Principal:** Create an Azure Active Directory (Azure AD) service principal (or managed identity for self-hosted agents) and grant it `Get` and `List` permissions on the secrets in your Key Vault.
3.  **Create an Azure DevOps Service Connection:** In your Azure DevOps project, create a Service Connection (e.g., "Azure Resource Manager" type) using the service principal created in the previous step.
4.  **Link Key Vault to a Variable Group:**
      * Go to **Pipelines -\> Library** in Azure DevOps.
      * Create a new **Variable Group**.
      * Enable **"Link secrets from an Azure key vault as variables."**
      * Select your Azure subscription and the Key Vault.
      * Authorize the connection (this uses the Service Connection).
      * Select the specific secrets from Key Vault that you want to expose as pipeline variables.
      * These secrets will then be available as variables in your pipeline tasks, but their values will be masked in logs.
5.  **Use Secrets in Pipeline YAML:**
    ```yaml
    variables:
    - group: MyKeyVaultSecrets # Name of your linked variable group

    steps:
    - task: AzurePowerShell@5
      inputs:
        azureSubscription: '<YourServiceConnectionName>'
        scriptType: 'InlineScript'
        script: |
          Write-Host "My Secret Value: $(MyDatabasePassword)" # This will be masked in logs
    ```

#### **VI. YAML Pipelines vs. Classic Editor Pipelines**

Azure DevOps offers two primary ways to define pipelines:

1.  **YAML Pipelines (Recommended):**

      * **Definition:** Pipelines are defined in a `azure-pipelines.yml` file (or other YAML files) stored directly in your Git repository alongside your application or IaC code.
      * **"Pipelines as Code":** Embraces the IaC philosophy.
      * **Benefits:**
          * **Version Control:** Pipeline definition is versioned with your code, enabling auditability, rollback, and collaboration via Git.
          * **Consistency:** Easier to replicate and standardize pipelines across projects.
          * **Templates:** Strong support for reusable YAML templates for common stages, jobs, or tasks.
          * **Atomic Commits:** Code and pipeline changes can be committed together, ensuring they are in sync.
          * **Local Editing:** Can be edited in any code editor, with excellent IntelliSense in VS Code (using the Azure Pipelines extension).
      * **Best for:** Most modern CI/CD scenarios, especially for IaC, microservices, and large teams.

2.  **Classic Editor Pipelines (UI-based):**

      * **Definition:** Pipelines are defined and configured through a graphical user interface (GUI) in the Azure DevOps portal.
      * **Benefits:**
          * **Simpler for Beginners:** Easier to get started without writing YAML code.
          * **Visual Workflow:** Provides a visual representation of the pipeline stages and tasks.
      * **Drawbacks:**
          * **No Version Control:** Changes are not inherently versioned with your code; tracking history is harder.
          * **Less Reusable:** Harder to share and reuse definitions across different pipelines.
          * **Manual Changes:** Susceptible to manual, undocumented changes.
      * **Best for:** Very simple, ad-hoc pipelines, or teams in early stages of DevOps adoption. Microsoft is focusing new feature development on YAML pipelines.

#### **VII. Best Practices for CI/CD Pipelines**

1.  **Source Control Everything:** Store all application code, IaC, and pipeline definitions in version control (Git).
2.  **Automate Everything Possible:** Aim for fully automated builds, tests, and deployments to dev/test environments.
3.  **Build Once, Deploy Many Times:** Build your application artifact only once in the CI pipeline and use that same artifact across all CD stages. Do not rebuild for each environment.
4.  **Keep Builds Fast:** Optimize build times by caching dependencies, running parallel tests, and splitting large builds into smaller ones.
5.  **Implement Comprehensive Automated Tests:** Integrate unit, integration, and functional tests into your CI/CD process to catch bugs early.
6.  **Use Small, Frequent Commits:** Encourages faster feedback loops and easier debugging.
7.  **Leverage Environments and Approvals/Gates:** Use Azure DevOps Environments to manage deployments and implement manual approvals or automated gates for critical stages (e.g., production).
8.  **Secure Your Pipeline:**
      * Use Azure Key Vault for all secrets.
      * Grant the principle running the pipeline (Service Connection) only the minimum necessary permissions (Least Privilege).
      * Regularly review pipeline permissions.
      * Avoid hardcoding sensitive information.
9.  **Modularize Pipelines with YAML Templates:** Create reusable YAML templates for common stages, jobs, or tasks to promote consistency and reduce duplication.
10. **Monitor Pipeline Health:** Track pipeline success rates, duration, and failures. Use dashboards and alerts to identify bottlenecks or issues.
11. **Implement Rollback Strategies:** Plan and test how you would revert a deployment in case of an issue.
12. **Build Observability:** Ensure your deployed applications and infrastructure are emitting logs and metrics that can be consumed by monitoring tools.

-----