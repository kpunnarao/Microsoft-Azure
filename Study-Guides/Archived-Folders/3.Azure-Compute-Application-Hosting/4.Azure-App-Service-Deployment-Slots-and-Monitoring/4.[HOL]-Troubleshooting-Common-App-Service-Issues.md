# Lab: Troubleshooting Common App Service Issues 🐛🔍

This lab will provide hands-on experience in diagnosing and troubleshooting a common App Service issue: an application crash or HTTP 500 error. 

You will deliberately introduce an error into your web application and then use Azure's built-in monitoring and diagnostic tools to pinpoint the cause.

## Lab Scenario 🚧

You have a Node.js web application running on Azure App Service. 

A new "feature" is introduced that causes the application to crash on startup, resulting in HTTP 500 errors for users. 

Your task is to identify why the application is failing using Azure's diagnostic tools, especially focusing on Application Logs and the "Diagnose and solve problems" blade.

**Resources you'll be working with:**

  * **Existing Web App**: `webapp-yourname-d16` (from previous labs)
  * **Existing App Service Plan**: `plan-webapp-lab`
  * **Existing Log Analytics Workspace**: `loganalytics-webapp-lab` (already configured to receive App Service logs)
  * **Source Code**: The Node.js `app.js` and `package.json` from the previous lab, with a deliberate error introduced.

-----

## Part 1: Prerequisites

Before you begin, ensure you have:

  * An active Azure Subscription.
  * Access to the Azure Portal ([portal.azure.com](https://portal.azure.com)).
  * **For Azure CLI/PowerShell methods**: Azure CLI and/or Azure PowerShell installed and configured locally, or access to Azure Cloud Shell.
  * **Web App with Node.js app deployed**: Ensure `webapp-yourname-d16` is running the Node.js application from the previous "Monitoring" lab. If it's still static HTML, please follow **Part 2 of "Day 17 Lab: Monitoring Azure App Service Performance"** to deploy the Node.js app first.
  * **Diagnostic Settings Configured**: Your App Service (`webapp-yourname-d16`) should be sending `AppServiceAppLogs` and `AppServiceHTTPLogs` to your `loganalytics-webapp-lab` workspace (from the previous lab, Part 4).
  * **Application Logging (File System) Enabled**: In your App Service (`webapp-yourname-d16`), go to **App Service logs** under **Monitoring**. Ensure "Application Logging (File System)" is **On** with a level of "Information" or "Verbose".

-----

## Part 2: Introduce a Deliberate Error and Deploy

We'll modify the `app.js` to create an intentional error that prevents it from starting correctly.

1.  **Modify Your `app.js` File**:

      * Open your local `app.js` file (the one from your `my-local-webapp` folder, or your GitHub repo clone).
      * Introduce a syntax error or a critical runtime error, for example, by adding an uninitialized variable or a misconfigured `require` statement that will cause a crash on startup.
      * **Example of an intentional error (add this line somewhere near the top of `app.js`):**
        ```javascript
        // THIS LINE WILL CAUSE AN ERROR: Attempting to use a non-existent module
        const nonExistentModule = require('this-module-does-not-exist-12345');
        ```
      * Your `app.js` should now look something like this:
        ```javascript
        const express = require('express');
        // THIS LINE WILL CAUSE AN ERROR: Attempting to use a non-existent module
        const nonExistentModule = require('this-module-does-not-exist-12345');
        const app = express();
        const port = process.env.PORT || 80;

        app.get('/', (req, res) => {
          console.log(`Request received at: ${new Date().toISOString()} for path: ${req.path}`);
          res.send(`
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Azure App Service Monitoring Lab</title>
                <style>
                    body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; background-color: #ffe6e6; } /* Changed color for error state */
                    h1 { color: #cc0000; }
                    p { font-size: 1.2em; }
                    .version { font-weight: bold; color: #cc0000; }
                </style>
            </head>
            <body>
                <h1>Application Error Detected!</h1>
                <p>Something went wrong. Please check back later.</p>
                <p class="version">This page indicates a problem.</p>
                <p>Accessed from: <span id="hostname">${req.hostname}</span></p>
            </body>
            </html>
          `);
        });

        app.listen(port, () => {
          console.log(`App listening on port ${port}`);
        });
        ```

2.  **Commit and Deploy the Error-Riddled Code**:

      * **Local Git**:
        ```bash
        cd my-local-webapp
        git add .
        git commit -m "Introduced intentional error for troubleshooting lab"
        git push azure main # or master
        ```
      * **GitHub (if configured for CI/CD)**: Push your changes to your GitHub repository. The GitHub Action should trigger a deployment.

3.  **Verify the Error**:

      * Once the deployment completes (it might show success for the deployment itself, but the app inside will fail), try Browse to your web app's URL: `http://webapp-yourname-d16.azurewebsites.net`.
      * You should now see an error page (e.g., "HTTP Error 500" or "Application Error"). This confirms the issue.

-----

## Part 3: Diagnose the Issue using Azure Portal Tools

Now, let's play the role of a troubleshooter.

### Method 1: Using "Diagnose and solve problems" (Primary Tool) 🌐

This is your first stop for most App Service issues.

1.  **Navigate to your Web App**: `webapp-yourname-d16`.
2.  **Access Diagnostics**:
      * In the left menu, under **"Monitoring"**, select **"Diagnose and solve problems"**.
3.  **Explore the Troubleshooters**:
      * Wait a few moments for the initial analysis to run.
      * Click on **"Availability and Performance"**.
      * Select **"Web App Down"** or **"Application Crashes"**.
      * The diagnostic tool will analyze recent data. Look for insights like:
          * **Recent Application Restarts**: This will likely show if your app is repeatedly crashing.
          * **Application Event Logs**: It might directly show the Node.js application crash with details like `Cannot find module 'this-module-does-not-exist-12345'`. This is often the quickest way to find the root cause for crashes.
          * **CPU Usage / Memory Usage**: While the app is down, these might be low, but could show spikes if it's repeatedly trying to start.
          * **HTTP 5xx Errors**: Confirm the high rate of server errors.
      * **Review the recommendations and details provided by the tool.** This tool is designed to guide you.

### Method 2: Using "Log Stream" (Real-time Console Output) 🌐

1.  **Navigate to your Web App**: `webapp-yourname-d16`.
2.  **Access Log Stream**:
      * In the left menu, under **"Monitoring"**, select **"Log stream"**.
3.  **Observe Live Logs**:
      * If your application is attempting to start and then crashing, you might see the error message (`Cannot find module 'this-module-does-not-exist-12345'`) directly in the log stream as the App Service environment tries to run your `app.js`.
      * The log stream is excellent for capturing immediate startup failures or runtime errors.

### Method 3: Using "Logs" (Log Analytics Workspace for Historical Data) 🌐

This is for deeper historical analysis and complex queries.

1.  **Navigate to your Log Analytics Workspace**: `loganalytics-webapp-lab`.
2.  **Access Logs Query Interface**:
      * In the left menu, under **"General"**, select **"Logs"**.
3.  **Query for Application Errors**:
      * Run the following KQL query. This will search your `AppServiceAppLogs` table for any error messages.
        ```kusto
        AppServiceAppLogs
        | where LogLevel == "Error" or LogLevel == "Fatal"
        | project TimeGenerated, Message, Exception # Exception column might contain stack trace
        | order by TimeGenerated desc
        ```
          * You should find the `Cannot find module 'this-module-does-not-exist-12345'` error message here, indicating the exact line or module that caused the crash.
      * **Query for HTTP 500 errors**:
        ```kusto
        AppServiceHTTPLogs
        | where HttpStatusCode == 500
        | project TimeGenerated, CsUriStem, ClientIp, UserAgent
        | order by TimeGenerated desc
        ```
          * This confirms that requests are indeed failing with server errors.

### Method 4: Using the Kudu Console (Advanced Tools / SCM) 🌐

The Kudu console offers direct access to the App Service's file system and diagnostic tools.

1.  **Access Kudu**:
      * Navigate to your Web App (`webapp-yourname-d16`).
      * In the left menu, under **"Development Tools"**, select **"Advanced Tools"**.
      * Click **"Go"**. This opens the Kudu console in a new browser tab.
2.  **Navigate to Log Files**:
      * In the Kudu console, click **"Debug console"** -\> **"CMD"** (or PowerShell).
      * Navigate to the `LogFiles` directory by typing `cd LogFiles` and pressing Enter.
      * **For Node.js/Linux apps**, you'll often find console output and startup errors in files like `docker_init.log` or files within subdirectories like `202x_xx_xx_xxxx_xxxxxxxx.txt`. Look for error messages similar to what you saw in the Log Stream.
      * For Windows apps, you'd typically look for `applicationHost.log` or logs within specific application folders.
3.  **Process Explorer (Kudu)**: You can also use "Process Explorer" in Kudu (under **Tools** menu) to see if your application process is even running or if it's repeatedly crashing and restarting.

-----

## Part 4: Fix the Issue and Redeploy

Now that you've identified the root cause, let's fix it.

1.  **Correct your `app.js` File**:
      * Remove the problematic line:
        ```javascript
        // THIS LINE WILL CAUSE AN ERROR: Attempting to use a non-existent module
        // const nonExistentModule = require('this-module-does-not-exist-12345'); // REMOVE OR COMMENT OUT THIS LINE
        ```
      * Optionally, change the `background-color` and `h1` color back to a "healthy" state (e.g., `#e6f7ff` and `#0056b3` respectively).
2.  **Commit and Redeploy the Fixed Code**:
      * **Local Git**:
        ```bash
        cd my-local-webapp
        git add .
        git commit -m "Fixed intentional error in app.js"
        git push azure main # or master
        ```
      * **GitHub**: Push your changes to your GitHub repository.
3.  **Verify the Fix**:
      * Once the deployment completes, browse to your web app's URL: `http://webapp-yourname-d16.azurewebsites.net`.
      * You should now see your "Welcome to the Monitoring Lab\!" page, confirming the application is back online.
      * Check the Log Stream and Log Analytics to confirm that the error messages have stopped and new successful requests are being logged.

-----

## Part 5: Cleaning Up Resources (Highly Recommended)

To avoid incurring ongoing costs, always delete resources you no longer need. Deleting the resource group will remove the Web App, App Service Plan, Log Analytics Workspace, and all associated components.

### Method 1: Azure Portal 🌐

1.  **Navigate to Resource Groups**: In the Azure Portal, go to **"Resource groups"**.
2.  Find and click on your resource group: **`rg-webapp-lab`**.
3.  On the resource group's Overview blade, click **"Delete resource group"**.
4.  Type `rg-webapp-lab` to confirm, then click **"Delete"**.

### Method 2: Azure CLI 🖥️

```bash
az group delete --name rg-webapp-lab --no-wait --yes
echo "Resource group 'rg-webapp-lab' deletion initiated."
```

### Method 3: Azure PowerShell 💻

```powershell
Remove-AzResourceGroup -Name "rg-webapp-lab" -Force -AsJob
Write-Host "Resource group 'rg-webapp-lab' deletion initiated."
```

-----

This lab has provided a practical, hands-on experience in using Azure's powerful diagnostic tools to troubleshoot a common App Service issue. 

By intentionally breaking and then fixing your application, you've learned how to leverage the "Diagnose and solve problems" blade, Log Stream, and Log Analytics queries to quickly identify and resolve problems.