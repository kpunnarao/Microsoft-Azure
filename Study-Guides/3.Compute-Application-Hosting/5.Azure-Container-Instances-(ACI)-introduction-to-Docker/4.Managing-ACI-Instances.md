# Azure Container Instances (ACI) & Introduction to Docker üê≥

We've successfully deployed a basic container. Now, let's explore how to **Manage ACI Instances**. 

While ACI is designed for simplicity and doesn't offer the same depth of management as, say, Azure Kubernetes Service (AKS), there are still key operations and considerations for keeping your containers running smoothly.

## Managing ACI Instances

Azure Container Instances (ACI) provides a lightweight and serverless platform for running containers, meaning you don't manage the underlying virtual machines. 

However, you still have control over the container instances themselves, including their lifecycle, resource allocation, networking, and persistent storage.

### 1\. Container Group Lifecycle Management

A **container group** is the top-level resource in ACI. It's a collection of containers that are scheduled on the same host machine and share a lifecycle, local network, and storage. Most ACI deployments involve a single container per group.

  * **Start**: When you create a container group, it starts automatically.
  * **Stop**:
      * **Purpose**: To stop a running container group and halt billing for CPU and memory resources. Useful for temporary shutdowns or when a task is completed.
      * **Behavior**: The container's state is preserved (if it's a short-lived stop), but the public IP address may change upon restart.
      * **Methods**:
          * **Azure Portal**: Navigate to your Container Instance -\> **Overview** -\> **Stop**.
          * **Azure CLI**: `az container stop --resource-group <resource-group-name> --name <container-name>`
          * **Azure PowerShell**: `Stop-AzContainerGroup -ResourceGroupName <resource-group-name> -Name <container-name>`
  * **Restart**:
      * **Purpose**: To restart a running or stopped container group. This is often used for troubleshooting or applying minor configuration changes that don't require recreation.
      * **Behavior**: The container's state will be lost unless external persistent storage is used. The IP address might change.
      * **Methods**:
          * **Azure Portal**: Navigate to your Container Instance -\> **Overview** -\> **Restart**.
          * **Azure CLI**: `az container restart --resource-group <resource-group-name> --name <container-name>`
          * **Azure PowerShell**: `Restart-AzContainerGroup -ResourceGroupName <resource-group-name> -Name <container-name>`
  * **Delete**:
      * **Purpose**: To permanently remove the container group and stop all billing.
      * **Methods**:
          * **Azure Portal**: Navigate to your Container Instance -\> **Overview** -\> **Delete**.
          * **Azure CLI**: `az container delete --resource-group <resource-group-name> --name <container-name> --yes`
          * **Azure PowerShell**: `Remove-AzContainerGroup -ResourceGroupName <resource-group-name> -Name <container-name> -Force`

### 2\. Scaling ACI Instances (Horizontal Scaling) ‚ÜîÔ∏è

**Important Distinction**: ACI is designed for *single* container groups or *small, co-located groups of containers*. It does *not* provide built-in autoscaling or load balancing *between* multiple container groups out of the box.

  * **Scaling Up/Down (Vertical Scaling)**: You can adjust the CPU and memory allocated to an existing container instance *by updating its properties*. However, this often involves restarting the container group.
      * **Azure CLI Example**:
        ```bash
        az container update \
          --resource-group <resource-group-name> \
          --name <container-name> \
          --cpu 2 \
          --memory 4
        ```
  * **Scaling Out (Horizontal Scaling)**: To handle increased load, you manually create *multiple, independent container groups* (each a separate ACI instance).
      * **Load Balancing**: If you need to distribute traffic across these multiple ACI instances, you typically place a load balancer like **Azure Application Gateway** or **Azure Load Balancer** in front of them. For simpler HTTP-based load balancing and static IPs, **Azure Front Door** or **Azure Traffic Manager** (for global distribution) could also be considered.
      * **Note**: For scenarios requiring automatic horizontal scaling, more complex orchestration (like Kubernetes via **Azure Kubernetes Service - AKS**, or the newer **Azure Container Apps**) is generally more suitable. ACI is more for burst workloads, scheduled tasks, or simple web apps that don't need complex scaling rules.

### 3\. Networking Configuration üåê

When deploying an ACI instance, you configure its networking.

  * **Public IP Address**: By default, ACI instances are assigned a public IP address and a FQDN, making them internet-accessible. This is what we used in the previous lab.
  * **Private IP (Virtual Network Integration)**: For enterprise scenarios, you can deploy ACI instances into an Azure Virtual Network. This allows your containers to:
      * Communicate securely with other resources in the same VNet (e.g., Azure SQL Database, Azure Functions).
      * Be exposed internally via a private IP address only (no public IP).
      * Access on-premises resources via a VPN gateway or ExpressRoute if the VNet is connected.
      * **Benefit**: Enhanced security and network control.
      * **Configuration**: Requires specifying a subnet within your VNet during container group creation.
  * **Ports**: You specify which ports your container exposes and whether they are TCP or UDP.

### 4\. Persistent Storage üíæ

By default, ACI containers are **stateless**. If a container restarts, crashes, or stops, any data written to its local filesystem is lost. For applications that need to persist data, you must mount an external volume.

  * **Azure File Share**: The most common and recommended method for persistent storage in ACI.

      * **How it works**: You create an Azure Storage Account and an Azure File Share within it. Then, during container creation, you mount this file share as a volume to a specific path inside your container.
      * **Benefit**: Data persists independently of the container's lifecycle. Multiple containers can potentially share the same file share (though careful access management is needed).
      * **Configuration**: Requires the storage account name, file share name, and a storage account key or managed identity for authentication.

  * **Empty Directory**: A temporary, ephemeral volume that is shared between containers within the *same container group*. Data in an empty directory is lost when the container group terminates.

  * **Git Repo**: Mounts a Git repository as a volume. Useful for quickly injecting configuration files or small scripts that don't change frequently.

### 5\. Environment Variables & Command Overrides ‚öôÔ∏è

  * **Environment Variables**: You can pass configuration settings to your containerized application via environment variables. This is a secure way to manage non-sensitive configurations.
      * **Secure Environment Variables**: For sensitive information like database passwords, ACI allows you to define *secure environment variables* which are encrypted and not visible in the Azure Portal or logs.
      * **Methods**: Set during `az container create` (e.g., `--environment-variables MY_VAR=value`), via YAML, or in the Portal.
  * **Command Overrides**: You can override the default command (CMD or ENTRYPOINT) defined in your Docker image when creating the container instance. This is useful for running specific scripts or different startup commands.

### 6\. Monitoring and Logging üìä

As seen in the previous lab, monitoring and logging are critical for ACI.

  * **Container Logs**: ACI automatically collects `stdout` and `stderr` from your containers.
      * **Azure Portal**: Viewable directly in the Container Instance blade under **"Logs"**.
      * **Azure CLI**: `az container logs`
  * **Azure Monitor Integration**: You can integrate ACI with Azure Monitor Log Analytics for more advanced querying, alerting, and visualization of container logs and metrics. This is done via **Diagnostic Settings**.

### 7\. Restart Policies üîÑ

For tasks that are designed to run to completion (e.g., batch jobs, build agents), ACI offers restart policies:

  * **`Always` (Default)**: The container group is always restarted, even if it completes successfully. Suitable for web servers or long-running services.
  * **`Never`**: The container group runs once and never restarts, regardless of exit code. Suitable for single-shot tasks where you only want one execution.
  * **`OnFailure`**: The container group restarts only if the process inside the container terminates with a non-zero exit code (indicating a failure). Useful for ensuring batch jobs complete successfully.

### ACI vs. Other Container Services (Brief Comparison) üöÄ

It's important to understand where ACI fits in the Azure container ecosystem:

  * **ACI**: Ideal for simple, isolated, single-container deployments, burst workloads, or scheduled tasks. You pay by the second for compute. No orchestration complexity.
  * **Azure Container Apps (ACA)**: Newer, built on Kubernetes and Dapr, designed for microservices and serverless containers. Provides automatic scaling, traffic splitting, managed HTTPS, and event-driven capabilities without managing Kubernetes. Often a better choice than ACI for full-fledged web apps or microservices that need scaling.
  * **Azure Kubernetes Service (AKS)**: Full-fledged managed Kubernetes for complex, distributed applications requiring high scalability, advanced networking, service discovery, and fine-grained control over clusters. Requires more operational overhead.

ACI is often used as a "building block" for other services (e.g., AKS can burst to ACI, or Azure Functions can trigger ACI) or for scenarios where simple, quick container execution is paramount.