# Day 15 Lab: Configuring Azure Virtual Machine Scale Sets (VMSS) üöÄ

We structure it to cover:

  * **Creating a basic VMSS**: This will establish the foundation.
  * **Connecting to VMSS instances**: A quick check to ensure they are accessible.
  * **Verifying scaling and distribution**: How to confirm that instances are being added/removed and are distributed across fault domains or availability zones.

This lab will guide you through the process of creating a basic Azure Virtual Machine Scale Set (VMSS), understanding its initial configuration, and verifying its deployment. 

We'll focus on getting a foundational VMSS set up before delving deeper into auto-scaling (which we covered conceptually earlier but can be revisited with hands-on).

Here's proposed outline for the lab:

**Lab: Configuring Azure Virtual Machine Scale Sets (VMSS)**

  * **Lab Scenario**: You need to deploy a highly scalable and available web application that can automatically adjust its capacity based on demand.
  * **Part 1: Prerequisites** (Azure subscription, access to portal/CLI/PS, understanding of VMSS concepts, SSH key pair).
  * **Part 2: Creating the Virtual Machine Scale Set**
      * Method 1: Azure Portal
      * Method 2: Azure CLI
      * Method 3: Azure PowerShell
  * **Part 3: Connecting to VMSS Instances** (Briefly, as we covered SSH extensively).
  * **Part 4: Verifying VMSS Configuration and Scaling** (Checking instance distribution, power state, and initial scale settings).
  * **Part 5: Clean Up Resources** (Deleting the resource group to remove the VMSS and all associated resources).

This comprehensive approach will ensure the user can deploy, verify, and clean up a VMSS, providing a solid practical understanding.

## Lab Scenario üè∞

You need to deploy a scalable web application that can automatically handle varying user loads. 

To achieve this, you'll use an Azure Virtual Machine Scale Set configured with an integrated load balancer.

**Resources to be created:**

  * **Resource Group**: `rg-vmss-lab`
  * **Location**: `East US` (or a region close to you that supports VMSS and ideally Availability Zones)
  * **Virtual Network**: Automatically created by VMSS
  * **Load Balancer**: Automatically created (Standard SKU)
  * **Virtual Machine Scale Set**: `vmss-web-app`
      * **Orchestration Mode**: Flexible (recommended for new deployments)
      * **Image**: `Ubuntu Server 20.04 LTS` (or a recent LTS version)
      * **Size**: `Standard_B2s` (or a similar small, economical size)
      * **Initial Instance Count**: `2`
      * **Authentication Type**: `SSH public key`
      * **Administrator Username**: `azureuser`
      * **Public Inbound Ports**: Allow SSH (Port 22), HTTP (Port 80)

-----

## Part 1: Prerequisites

Before you begin, ensure you have:

  * An active Azure Subscription.
  * Access to the Azure Portal ([portal.azure.com](https://portal.azure.com)).
  * **For Azure CLI/PowerShell methods**: Azure CLI and/or Azure PowerShell installed and configured locally, or access to Azure Cloud Shell.
  * **For SSH Public Key authentication**: A generated SSH key pair (public and private key). You will need the content of your public key. If you don't have one, refer to Day 14's "Creating a Linux VM" lab for instructions on `ssh-keygen`.

-----

## Part 2: Creating the Virtual Machine Scale Set

We will create a VMSS with Flexible orchestration mode, which provides greater control and better integration with other Azure VM features.

### Method 1: Azure Portal üåê

1.  **Sign in to the Azure Portal**:

      * Open your web browser and navigate to [**portal.azure.com**](https://portal.azure.com).
      * Sign in with your Azure account credentials.

2.  **Navigate to Virtual Machine Scale Sets**:

      * In the Azure Portal's global search bar, type "Virtual machine scale sets" and select **"Virtual machine scale sets"** from the search results.

3.  **Start Creation Process**:

      * On the Virtual machine scale sets blade, click **"+ Create"**.

4.  **Configure Basics**:

      * **Project details**:
          * **Subscription**: Select your Azure subscription.
          * **Resource group**: Click **"Create new"** and enter `rg-vmss-lab`. Click **"OK"**.
      * **Scale set details**:
          * **Virtual machine scale set name**: Enter `vmss-web-app`.
          * **Region**: Select **"East US"** (or a region that supports Availability Zones, e.g., `East US 2`, `West US 2`, `North Europe`).
          * **Availability options**: Select **"Availability zone"**. (This is recommended for higher SLA with Flexible orchestration).
          * **Zones**: Select **all three zones (1, 2, 3)**. This will distribute your VMs across zones.
          * **Orchestration mode**: Select **"Flexible"**.
      * **Instance details**:
          * **Image**: `Ubuntu Server 20.04 LTS`
          * **VM architecture**: `x64`
          * **Azure Spot instance**: Leave unchecked (`No`).
          * **Size**: `Standard_B2s` (or a similar small, economical size).
      * **Administrator account**:
          * **Authentication type**: `SSH public key`
          * **Username**: `azureuser`
          * **SSH public key source**: `Use existing public key`
          * **SSH public key**: Paste the content of your `id_rsa_azure.pub` file.
      * **Inbound port rules**:
          * **Public inbound ports**: `Allow selected ports`
          * **Select inbound ports**: Check `SSH (22)` and `HTTP (80)` (for the web app).

5.  **Configure Disks**:

      * Keep the defaults for OS disk type and encryption. Click **"Next: Networking \>"**.

6.  **Configure Networking**:

      * **Virtual network**: Leave default (a new VNet will be created, e.g., `rg-vmss-lab-vnet`).
      * **Load balancing**: Select **"Yes"**.
          * **Load balancing options**: `Azure Load Balancer`
          * **Load balancer name**: Keep default (e.g., `vmss-web-app-lb`).
          * **Load balancer public IP address**: Keep default (a new public IP will be created).
          * **Backend pool name**: Keep default (e.g., `vmss-web-app-beap`).
          * **Load balancing port**: `80` (for HTTP traffic).
      * Keep other networking settings as default. Click **"Next: Scaling \>"**.

7.  **Configure Scaling**:

      * **Initial instance count**: `2` (We will start with 2 instances).
      * **Scaling policy**: Choose **"Custom autoscale"**.
          * This will take you to the auto-scale configuration screen we discussed. For simplicity for *this* lab, you can temporarily set the "Initial instance count" back to `2` and "Scaling policy" to "Manual scale" on this screen if you want to skip the autoscale configuration for now, or just follow the previous lab's instructions to add the CPU-based rules here. For this lab, let's keep it simple: just ensure "Manual scale" and "Initial instance count" is 2. (We can revisit the autoscale settings after the VMSS is deployed).
      * Click **"Next: Management \>"**.

8.  **Configure Management, Health, Advanced, and Tags**:

      * Review these tabs; for a basic deployment, defaults are usually fine.
      * Click **"Review + create"** then **"Create"**.
      * The deployment will take several minutes as it provisions the VNet, Load Balancer, and the VMSS instances.

-----

### Method 2: Azure CLI üñ•Ô∏è

1.  **Open Azure Cloud Shell (Bash) or your local Terminal with Azure CLI installed**.

      * Ensure you are logged in to Azure CLI (`az login`).

2.  **Set Variables**:

    ```bash
    resourceGroup="rg-vmss-lab"
    location="eastus" # Or an AZ-supported region like eastus2, westus2, northeurope
    vmssName="vmss-web-app"
    adminUsername="azureuser"
    sshPublicKeyPath="~/.ssh/id_rsa_azure.pub" # Adjust path if needed
    ```

3.  **Create Resource Group (if it doesn't exist)**:

    ```bash
    az group create --name $resourceGroup --location $location
    ```

4.  **Create the Virtual Machine Scale Set (Flexible orchestration, with Zones and Load Balancer)**:

    ```bash
    az vmss create \
      --resource-group $resourceGroup \
      --name $vmssName \
      --image UbuntuLTS \
      --admin-username $adminUsername \
      --ssh-key-values $sshPublicKeyPath \
      --instance-count 2 \
      --location $location \
      --public-ip-sku Standard \
      --load-balancer Standard \
      --backend-port 80 \
      --orchestration-mode Flexible \
      --zones 1 2 3 \
      --nsg-rule SSH \
      --no-wait
    ```

      * `--zones 1 2 3`: This is crucial for distributing instances across Availability Zones.
      * `--orchestration-mode Flexible`: Specifies the orchestration mode.
      * `--load-balancer Standard`: Creates a Standard SKU Load Balancer.
      * `--backend-port 80`: Configures the Load Balancer to send traffic on port 80 to backend instances.
      * `--nsg-rule SSH`: Adds a Network Security Group rule to allow SSH (port 22).

-----

### Method 3: Azure PowerShell üíª

1.  **Open Azure Cloud Shell (PowerShell) or your local PowerShell 7 terminal with Azure PowerShell installed**.

      * Ensure you are logged in to Azure PowerShell (`Connect-AzAccount`).

2.  **Set Variables**:

    ```powershell
    $resourceGroupName = "rg-vmss-lab"
    $location = "EastUS" # Or an AZ-supported region like EastUS2, WestUS2, NorthEurope
    $vmssName = "vmss-web-app"
    $adminUsername = "azureuser"
    $sshPublicKeyPath = "$env:USERPROFILE\.ssh\id_rsa_azure.pub" # Adjust for Windows path or Linux/macOS
    $sshPublicKey = Get-Content -Path $sshPublicKeyPath -Raw
    $initialInstanceCount = 2
    ```

3.  **Create Resource Group (if it doesn't exist)**:

    ```powershell
    New-AzResourceGroup -Name $resourceGroupName -Location $location
    ```

4.  **Create VMSS Configuration Object**:

    ```powershell
    # Define Network Interface Configuration
    $nicConfig = New-AzVmssNetworkInterfaceConfiguration -Name "vmss-nic" -Primary `
        -IPConfiguration (New-AzVmssIPConfig -Name "vmss-ipconfig" -SubnetPrefix "10.0.0.0/24" -PublicIpAddressConfigurationName "vmss-pip-config") `
        -EnableAcceleratedNetworking $true

    # Define VMSS Configuration
    $vmssConfig = New-AzVmssConfig -Location $location -VMName $vmssName -SkuName "Standard_B2s" -ImageName "UbuntuServer" -ImagePublisher "Canonical" -ImageOffer "UbuntuServer" -ImageSku "20.04-LTS" -InstanceCount $initialInstanceCount `
        -NetworkInterfaceConfiguration $nicConfig `
        -Zone "1","2","3" ` # Deploy across Availability Zones
        -OrchestrationMode "Flexible" ` # Set Flexible orchestration mode
        -UpgradePolicyMode "Automatic" # Example upgrade policy

    # Add Admin Credentials (SSH Public Key)
    Set-AzVmssOsProfile -VirtualMachineScaleSet $vmssConfig -ComputerNamePrefix "webapp" -AdminUsername $adminUsername -Linux -SshKeyData $sshPublicKey

    # Add Network Security Group rule for SSH and HTTP
    $nsgRuleSSH = New-AzNetworkSecurityRuleConfig -Name "SSH" -Description "Allow SSH" -Access "Allow" -Protocol "Tcp" -Direction "Inbound" -Priority 1000 -SourceAddressPrefix "*" -SourcePortRange "*" -DestinationAddressPrefix "*" -DestinationPortRange 22
    $nsgRuleHTTP = New-AzNetworkSecurityRuleConfig -Name "HTTP" -Description "Allow HTTP" -Access "Allow" -Protocol "Tcp" -Direction "Inbound" -Priority 1010 -SourceAddressPrefix "*" -SourcePortRange "*" -DestinationAddressPrefix "*" -DestinationPortRange 80
    Set-AzVmssNetworkSecurityGroup -VirtualMachineScaleSet $vmssConfig -NetworkSecurityGroupRule $nsgRuleSSH, $nsgRuleHTTP

    # Configure Load Balancer
    $lb = New-AzLoadBalancer -ResourceGroupName $resourceGroupName -Name ($vmssName + "-lb") -Location $location -Sku Standard -FrontendIpConfiguration (New-AzLoadBalancerFrontendIpConfig -Name "lb-fe-ip" -PublicIpAddress (New-AzPublicIpAddress -ResourceGroupName $resourceGroupName -Name ($vmssName + "-lb-pip") -Location $location -AllocationMethod Static -Sku Standard))

    $lbBackendPool = Add-AzLoadBalancerBackendAddressPoolConfig -Name "web-backend-pool" -LoadBalancer $lb
    $lbProbe = Add-AzLoadBalancerProbeConfig -Name "http-probe" -Protocol Http -Port 80 -IntervalInSeconds 5 -ProbeCount 2 -LoadBalancer $lb
    $lbRule = Add-AzLoadBalancerRuleConfig -Name "http-rule" -FrontendIpConfiguration $lb.FrontendIpConfigurations[0] -BackendAddressPool $lbBackendPool -Probe $lbProbe -Protocol Tcp -FrontendPort 80 -BackendPort 80 -LoadBalancer $lb -EnableFloatingIP $false

    Set-AzVmssLoadBalancer -VirtualMachineScaleSet $vmssConfig -LoadBalancerId $lb.Id -LoadBalancerBackendAddressPoolId $lbBackendPool.Id
    ```

      * **Note**: PowerShell VMSS creation, especially with networking and load balancers, is quite verbose due to the need to define all nested configurations.

5.  **Create the VMSS**:

    ```powershell
    New-AzVmss -ResourceGroupName $resourceGroupName -VMScaleSet $vmssConfig -Verbose
    ```

    The deployment will take several minutes.

-----

## Part 3: Connecting to VMSS Instances (Briefly)

You typically connect to VMSS instances via their associated Load Balancer or through a jumpbox, rather than directly to individual public IPs (which VMSS instances generally don't have by default unless configured).

1.  **Get Load Balancer Public IP**:

      * **Azure Portal**: Go to your Resource Group `rg-vmss-lab`, find the Load Balancer (e.g., `vmss-web-app-lb`), and copy its Public IP Address from the Overview blade.
      * **Azure CLI**: `az network public-ip show --resource-group rg-vmss-lab --name vmss-web-app-lb-pip --query ipAddress -o tsv`
      * **Azure PowerShell**: `(Get-AzPublicIpAddress -ResourceGroupName rg-vmss-lab -Name "vmss-web-app-lb-pip").IpAddress`

2.  **SSH via Load Balancer (using NAT rules - not configured by default in the lab above but common)**:

      * For SSH, you'd usually create an **Inbound NAT Rule** on the Load Balancer, mapping a unique front-end port (e.g., 22001) to port 22 of a specific VMSS instance's private IP. This lab setup does not include such NAT rules for simplicity.
      * **Alternative (for testing/jumpbox scenarios)**: SSH to the instances' *private IP addresses* if you are within the same VNet (e.g., from a jumpbox VM or via Azure Bastion).
      * **Simplest for now**: The VMs have public IPs *on their NICs* (due to `--public-ip-sku Standard` with Flexible Orchestration), so you can directly get the public IP of an individual instance for SSH:
          * **Azure Portal**: Navigate to your VMSS, then click on **"Instances"**. You'll see `vmss-web-app_0`, `vmss-web-app_1`, etc. Click on an instance name, then its Network Interface to find its public IP.
          * **Azure CLI**:
            ```bash
            az vm list-ip-addresses -g $resourceGroup --query "[?contains(virtualMachine.id, '$vmssName')].{Name:virtualMachine.name, PrivateIPs:virtualMachine.network.privateIpAddresses[0], PublicIPs:virtualMachine.network.publicIpAddresses[0].ipAddress}" -o table
            ```
            Once you have an IP, `ssh azureuser@<Public_IP_of_VMSS_Instance>`.

3.  **Install a simple web server (Optional)**:

      * SSH into one of the instances (e.g., `vmss-web-app_0`).
      * Run: `sudo apt update && sudo apt install nginx -y`
      * Verify Nginx is running: `systemctl status nginx`
      * Exit SSH.
      * Now, open a web browser and navigate to the **Load Balancer's Public IP**. You should see the Nginx welcome page, demonstrating traffic distribution.

-----

## Part 4: Verifying VMSS Configuration and Scaling

1.  **Azure Portal Verification**:

      * Go to your VMSS (`vmss-web-app`) in the Azure Portal.
      * On the **Overview** blade, check the **"Instances"** count (should be 2).
      * Go to **"Instances"** under **"Settings"**:
          * Observe the list of VM instances (e.g., `vmss-web-app_0`, `vmss-web-app_1`).
          * For Flexible orchestration, you can actually see their individual VM resources and even their **Fault Domain** and **Availability Zone** assignments in the columns. Notice how Azure distributed them across the zones you selected (e.g., one in Zone 1, one in Zone 2).
      * Go to **"Scaling"** under **"Settings"**:
          * Confirm the initial instance count and whether `Autoscale` is enabled or set to `Manual scale`.

2.  **Azure CLI Verification**:

    ```bash
    # Get overall VMSS details
    az vmss show --resource-group $resourceGroup --name $vmssName --query "{Name:name, Location:location, InstanceCount:sku.capacity, OrchestrationMode:orchestrationMode, Zones:zones}" -o jsonc

    # List individual VMSS instances with their domains/zones
    echo "VMSS Instances with Fault Domains and Zones:"
    az vmss list-instances --resource-group $resourceGroup --name $vmssName --query "[].{Name:name, PowerState:powerState, FaultDomain:platformFaultDomain, Zone:zone}" -o table
    ```

      * You should see `PowerState` as `VM running`.
      * `FaultDomain` will show the specific fault domain within a zone (or within the region if not using zones).
      * `Zone` will show `1`, `2`, or `3` indicating their Availability Zone distribution.

3.  **Azure PowerShell Verification**:

    ```powershell
    $resourceGroupName = "rg-vmss-lab"
    $vmssName = "vmss-web-app"

    # Get overall VMSS details
    Get-AzVmss -ResourceGroupName $resourceGroupName -Name $vmssName | Format-List Name, Location, Sku, ProvisioningState, OrchestrationMode, Zones

    # List individual VMSS instances with their domains/zones
    Write-Host "VMSS Instances with Fault Domains and Zones:"
    Get-AzVmssVM -ResourceGroupName $resourceGroupName -VMScaleSetName $vmssName | Select-Object Name, PowerState, @{N='FaultDomain';E={$_.InstanceView.PlatformFaultDomain}}, @{N='Zone';E={$_.Zones}} | Format-Table
    ```

-----

## Part 5: Cleaning Up Resources (Highly Recommended)

To avoid incurring ongoing costs, always delete resources you no longer need. Deleting the resource group will remove the VMSS, load balancer, public IPs, disks, network interfaces, and any associated networking components.

### Method 1: Azure Portal üåê

1.  **Navigate to Resource Groups**: In the Azure Portal, go to **"Resource groups"**.
2.  Find and click on your resource group: **`rg-vmss-lab`**.
3.  On the resource group's Overview blade, click **"Delete resource group"**.
4.  Type `rg-vmss-lab` to confirm, then click **"Delete"**.

### Method 2: Azure CLI üñ•Ô∏è

```bash
az group delete --name rg-vmss-lab --no-wait --yes
echo "Resource group 'rg-vmss-lab' deletion initiated."
```

### Method 3: Azure PowerShell üíª

```powershell
Remove-AzResourceGroup -Name "rg-vmss-lab" -Force -AsJob
Write-Host "Resource group 'rg-vmss-lab' deletion initiated."
```

-----

This lab provides a solid foundation for understanding and deploying Azure Virtual Machine Scale Sets, which are vital for building scalable and highly available cloud-native applications.