# Lab: Creating a Simple HTTP-triggered Azure Function üöÄüíª

This lab will guide you through creating, running, and deploying a basic "Hello World" HTTP-triggered Azure Function.

For this lab, we'll use **Python** as the language, as it's widely used and great for serverless functions. 

We'll leverage the **Azure Functions Core Tools** and **Visual Studio Code** for a smooth development experience.

## Lab Scenario üåê

You need to create a simple serverless API endpoint that responds to HTTP GET requests. 

This function will take an optional `name` parameter in the query string and return a personalized greeting. 

If no name is provided, it will return a generic greeting.

**Resources you'll be creating in Azure (if you deploy):**

  * **New Resource Group**: `rg-functions-lab`
  * **New Storage Account**: Automatically created for the Function App (e.g., `functionappstoragenamexyz`).
  * **New Function App**: `myfunctionapp-yourname` (e.g., `myfunctionapp-johnsmith`).
  * **New HTTP Trigger Function**: `HttpExample`

-----

## Part 1: Prerequisites

Before you begin, ensure you have the following installed on your local machine:

1.  **Azure Account**: An active Azure subscription. If you don't have one, you can create a [free account](https://azure.microsoft.com/free/).
2.  **Python**: A supported version of Python (e.g., 3.8, 3.9, 3.10, 3.11).
3.  **Visual Studio Code (VS Code)**: The popular code editor.
      * [Download VS Code](https://code.visualstudio.com/)
4.  **Azure Functions Extension for VS Code**:
      * Open VS Code, go to the Extensions view (Ctrl+Shift+X or Cmd+Shift+X), search for "Azure Functions", and install it.
5.  **Azure Functions Core Tools**: These tools allow you to develop and run Azure Functions locally.
      * **Recommended Method (via VS Code):**
          * In VS Code, open the Command Palette (Ctrl+Shift+P or Cmd+Shift+P).
          * Type `Azure Functions: Install or Update Core Tools` and select it. Follow any prompts.
      * **Alternative (Manual Installation - if VS Code method fails or you prefer):**
          * **npm (Node.js required):** `npm install -g azure-functions-core-tools@4 --unsafe-perm true`
          * **Homebrew (macOS):** `brew tap azure/functions && brew install azure-functions-core-tools@4`
          * **Chocolatey (Windows):** `choco install azure-functions-core-tools`
          * **Winget (Windows):** `winget install Microsoft.Azure.FunctionsCoreTools`
          * **Linux (APT - Ubuntu/Debian):**
            ```bash
            wget -q https://packages.microsoft.com/config/ubuntu/<YOUR_UBUNTU_VERSION_HERE>/packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install azure-functions-core-tools-4
            ```
            *(Replace `<YOUR_UBUNTU_VERSION_HERE>` with your version, e.g., `22.04`)*
      * **Verify Installation**: Open a new terminal and run `func --version`. You should see `4.x.x.x`.
6.  **Azure CLI (Optional, for deploying from terminal):** If you prefer not to use the VS Code extension for deployment, you'll need Azure CLI.
      * [Install Azure CLI](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
      * Log in: `az login`

-----

## Part 2: Create Your Local Functions Project

We'll use VS Code to create a new Azure Functions project and an HTTP-triggered function within it.

1.  **Open VS Code.**
2.  **Open the Command Palette** (Ctrl+Shift+P or Cmd+Shift+P).
3.  Type `Azure Functions: Create New Project...` and select it.
4.  **Select a folder**: Choose an *empty* directory or create a new one for your project (e.g., `C:\FunctionsProjects\MyHttpFunctionApp`).
      * Click `Select`.
5.  **Select a language**: Choose `Python (Programming Model V2)`.
6.  **Select a Python interpreter**: Choose your preferred Python interpreter (e.g., `Python 3.10.x 64-bit`). This will create a virtual environment.
7.  **Select a template for your project's first function**: Choose `HTTP trigger`.
8.  **Provide a function name**: Type `HttpExample` and press Enter.
9.  **Authorization level**: Choose `Anonymous`. This means anyone can call your function without an API key (good for testing).
10. **Select how you would like to open your project**: Choose `Open in current window`.

VS Code will now create the project structure. You'll see files like:

  * `function_app.py`: This is where your function code resides.
  * `requirements.txt`: Lists Python dependencies.
  * `host.json`: Global configuration for the Function App.
  * `local.settings.json`: Local settings (like connection strings) that are not deployed to Azure.

### Examine the Generated Code (`function_app.py`)

Open `function_app.py`. You'll see a structure similar to this (exact code might vary slightly based on template updates):

```python
import azure.functions as func
import logging

app = func.FunctionApp()

@app.route(route="HttpExample", auth_level=func.AuthLevel.ANONYMOUS)
def HttpExample(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function processed a request.')

    name = req.params.get('name')
    if not name:
        try:
            req_body = req.get_json()
        except ValueError:
            pass
        else:
            name = req_body.get('name')

    if name:
        return func.HttpResponse(
            f"Hello, {name}. This HTTP triggered function executed successfully."
        )
    else:
        return func.HttpResponse(
            "Please pass a name on the query string or in the request body for a personalized response.",
            status_code=200
        )
```

**Code Explanation**:

  * `import azure.functions as func`: Imports the Azure Functions SDK for Python.
  * `app = func.FunctionApp()`: Creates an instance of the Function App.
  * `@app.route(...)`: This is a **decorator** that defines the HTTP trigger.
      * `route="HttpExample"`: Sets the URL path segment for this function (e.g., `/api/HttpExample`).
      * `auth_level=func.AuthLevel.ANONYMOUS`: Specifies no authentication is required.
  * `def HttpExample(req: func.HttpRequest) -> func.HttpResponse:`: The main function entry point.
      * `req: func.HttpRequest`: The input parameter representing the incoming HTTP request.
      * `-> func.HttpResponse`: Indicates the function returns an HTTP response.
  * The logic attempts to get a `name` from the query string (`req.params.get('name')`) or the request body (`req.get_json()`).
  * It then constructs an `HttpResponse` with a personalized greeting or a generic message.

-----

## Part 3: Run the Function Locally

The Azure Functions Core Tools allow you to run and debug your functions on your local machine, mimicking the Azure environment.

1.  **Open the Terminal in VS Code** (Terminal -\> New Terminal, or Ctrl+\`).

2.  **Activate the Virtual Environment**:

      * **Windows (Cmd/PowerShell):** `.\.venv\Scripts\activate`
      * **Linux/macOS (Bash/Zsh):** `source ./.venv/bin/activate`

3.  **Install Dependencies**:

      * `pip install -r requirements.txt` (This installs `azure-functions` and any other packages listed).

4.  **Start the Functions Host**:

      * `func start`
      * You should see output indicating that the Functions host is starting and detecting your `HttpExample` function. Look for a line like:
        ```
        Http Functions:
                HttpExample: http://localhost:7071/api/HttpExample
        ```
      * Keep this terminal window open.

5.  **Test the Function in your Browser or with `curl`**:

      * **Browser**: Open your web browser and navigate to the URL: `http://localhost:7071/api/HttpExample`
          * You should see: "Please pass a name on the query string or in the request body for a personalized response."
      * **Browser (with query parameter)**: `http://localhost:7071/api/HttpExample?name=AzureUser`
          * You should see: "Hello, AzureUser. This HTTP triggered function executed successfully."
      * **`curl` (with query parameter)**:
        ```bash
        curl "http://localhost:7071/api/HttpExample?name=CurlUser"
        ```
      * **`curl` (with POST body)**:
        ```bash
        curl -X POST -H "Content-Type: application/json" -d '{"name": "PostMan"}' http://localhost:7071/api/HttpExample
        ```
      * Check the VS Code terminal where `func start` is running; you'll see log messages indicating your function was executed.

6.  **Stop the Function Host**: Go back to the terminal where `func start` is running and press **Ctrl+C**.

-----

## Part 4: Deploy the Function to Azure

Now that your function works locally, let's deploy it to a live Azure Function App.

### Method 1: Deploy using Azure Functions Extension in VS Code (Recommended)

1.  **Sign in to Azure**:

      * In VS Code, open the **Azure extension** sidebar (the Azure icon on the left activity bar).
      * Under **Functions**, click "Sign in to Azure..." and follow the prompts.

2.  **Deploy to Function App**:

      * In the Azure extension sidebar, under **Functions**, click the **Deploy to Function App** button (the blue arrow icon).
      * Select your current project folder when prompted.
      * Choose your subscription.
      * Select `+ Create new Function App in Azure`.
      * **Enter a globally unique name for the Function App**: Type a unique name like `myfunctionapp-yourname-d20` (e.g., `myfunctionapp-johnsmith-d20`).
      * **Select a runtime stack**: Choose `Python 3.x` (match your local Python version).
      * **Select a location**: Choose a region close to you (e.g., `East US`).
      * Wait for the deployment to complete. You'll see progress in the VS Code output window. This step will provision:
          * A new **Resource Group** (e.g., `myfunctionapp-yourname-d20-rg`).
          * An **Azure Storage Account** (e.g., `myfunctionappyournamexyz`).
          * The **Azure Function App** resource.
          * And then deploy your function code to it.

3.  **Get the Deployed Function URL**:

      * Once deployment is complete, expand your subscription in the Azure extension sidebar -\> **Function Apps** -\> your new Function App -\> **Functions** -\> `HttpExample`.
      * Right-click `HttpExample` and select **"Copy Function URL"**.
      * The URL will look something like: `https://myfunctionapp-yourname-d20.azurewebsites.net/api/HttpExample`.

4.  **Test the Deployed Function**:

      * Paste the copied URL into your web browser. You should get the generic response.
      * Append `?name=CloudGuru` to the URL: `https://myfunctionapp-yourname-d20.azurewebsites.net/api/HttpExample?name=CloudGuru`.
          * You should see: "Hello, CloudGuru. This HTTP triggered function executed successfully."

### Method 2: Deploy using Azure CLI (Alternative)

1.  **Ensure you are logged in to Azure CLI**: `az login`
2.  **Create a Resource Group**:
    ```bash
    resourceGroup="rg-functions-lab"
    location="eastus" # Choose a region close to you
    az group create --name $resourceGroup --location $location
    ```
3.  **Create a Storage Account (required by Function App)**:
    ```bash
    storageName="youruniqueappstorage$(head /dev/urandom | tr -dc a-z0-9 | head -c 10)" # Unique name!
    az storage account create --name $storageName --location $location --resource-group $resourceGroup --sku Standard_LRS
    ```
4.  **Create the Function App**:
    ```bash
    functionAppName="myfunctionapp-yourname-d20-cli" # Globally unique name!
    az functionapp create --resource-group $resourceGroup --consumption-plan-location $location \
      --runtime python --runtime-version 3.10 --functions-version 4 \
      --name $functionAppName --storage-account $storageName
    ```
    *(Adjust `--runtime-version` to your Python version)*
5.  **Deploy your local code to the Function App**:
      * Navigate your terminal to the root of your local Azure Functions project (the folder containing `host.json` and `function_app.py`).
    <!-- end list -->
    ```bash
    func azure functionapp publish $functionAppName
    ```
      * This command will zip your code and deploy it to the specified Function App.
6.  **Get the Function URL**:
    ```bash
    az functionapp show --name $functionAppName --resource-group $resourceGroup --query "defaultHostName" -o tsv
    # The URL will be: https://<defaultHostName>/api/HttpExample
    ```
7.  **Test the function** as described in Method 1, step 4.

-----

## Part 5: View Live Logs (Optional but Recommended)

You can view streaming logs from your deployed Function App to see executions in real-time.

1.  **Azure Portal**:

      * Navigate to your Function App in the Azure Portal.
      * In the left menu, under **"Functions"**, select **"Functions"**, then click on your `HttpExample` function.
      * Go to **"Code + Test"** -\> **"Test/Run"**.
      * Click on **"Logs"** (below the "Input" and "Output" tabs). You'll see the log stream activate.
      * Now, call your function from the browser or `curl` again. You'll see the `Python HTTP trigger function processed a request.` message appear in the logs.

2.  **Azure CLI**:

    ```bash
    az functionapp logstream --name myfunctionapp-yourname-d20 --resource-group rg-functions-lab
    ```

      * Call your function, and logs will appear in your terminal. Press Ctrl+C to stop.

-----

## Part 6: Cleaning Up Resources (Highly Recommended)

To avoid incurring ongoing costs, always delete resources you no longer need. Deleting the resource group will remove the Function App, Storage Account, and all associated components.

### Method 1: Azure Portal üåê

1.  **Navigate to Resource Groups**: In the Azure Portal, go to **"Resource groups"**.
2.  Find and click on your resource group: `rg-functions-lab` (or the one automatically created by VS Code, e.g., `myfunctionapp-yourname-d20-rg`).
3.  On the resource group's Overview blade, click **"Delete resource group"**.
4.  Type the resource group name to confirm, then click **"Delete"**.

### Method 2: Azure CLI üñ•Ô∏è

```bash
az group delete --name rg-functions-lab --no-wait --yes
echo "Resource group 'rg-functions-lab' deletion initiated."
```

-----

Congratulations\! You've successfully created, run locally, and deployed your first HTTP-triggered Azure Function. You've experienced the speed and serverless nature of this compute model firsthand.
