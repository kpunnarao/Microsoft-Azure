# Understanding Request Units (RUs) in Azure Cosmos DB


**Request Units (RUs)**, which are the fundamental currency for throughput in Azure Cosmos DB. Understanding RUs is critical for designing performant and cost-effective Cosmos DB solutions.

In Azure Cosmos DB, a **Request Unit (RU)** is the fundamental measure of throughput. 

Think of it as a normalized performance currency that abstracts the system resources required to perform various database operations. Instead of dealing with CPU, IOPS, and memory, you deal with RUs.

Every operation you perform in Azure Cosmos DB – whether it's a read, write, update, delete, or query – consumes a certain number of RUs. The more complex an operation, the more RUs it consumes.

### 1. What is an RU/s?

**Request Units per second (RU/s)** is the throughput that you provision for your Azure Cosmos DB account, database, or container. It represents the number of RUs that your application can consume per second. 

If your application attempts to consume more RUs than your provisioned RU/s in any given second, Cosmos DB will "rate-limit" (throttle) the requests, returning an HTTP 429 error. Your application should be designed to handle these retries.

A simple point read (fetching a single item by its ID and partition key) of a 1 KB item typically costs **1 RU**. This serves as a baseline for understanding the cost of other operations.

### 2. Factors Affecting RU Consumption

The number of RUs consumed by an operation depends on several factors:

* **Item Size**: Larger items consume more RUs for both read and write operations.
* **Item Indexing**:
    * **Writes**: If your indexing policy is set to index all properties (the default), writing an item with many properties will consume more RUs as more index updates are required. Limiting indexed properties reduces write RU cost.
    * **Reads/Queries**: Properly indexed properties significantly reduce query RUs by allowing Cosmos DB to perform efficient index lookups instead of scanning.
* **Number of Properties**: More properties in an item (especially if indexed) increase the RU cost for writes.
* **Query Complexity**:
    * **Point Reads vs. Queries**: Point reads (by ID and partition key) are the most efficient (lowest RU cost).
    * **Filters, Joins, Aggregations, Order By**: More complex queries involving these operations consume more RUs.
    * **Cross-Partition Queries**: Queries that span multiple logical partitions typically consume significantly more RUs than single-partition queries because they involve fan-out operations across physical partitions.
    * **Number of Results**: The amount of data returned by a query impacts its RU cost.
    * **User-Defined Functions (UDFs) / Stored Procedures / Triggers**: The complexity of the logic within these server-side scripts directly affects RU consumption.
* **Data Consistency Level**: Stronger consistency levels (Strong, Bounded Staleness) typically consume approximately two times more RUs for read operations compared to more relaxed consistency levels (Session, Consistent Prefix, Eventual), due to increased synchronization overhead.
* **Number of Physical Partitions**: While abstracted, underlying physical partition management can influence costs, especially if you have "hot partitions" (a few logical partitions consuming a disproportionate amount of RU/s).

### 3. Capacity Modes and Billing

Azure Cosmos DB offers different ways to provision and pay for throughput, directly impacting how RUs are billed:

#### a. Provisioned Throughput (Manual)

* **How it Works**: You explicitly set a fixed amount of RU/s (e.g., 400 RU/s, 1000 RU/s) that is reserved for your database or container 24/7.
* **Billing**: You are billed **hourly for the RU/s you provisioned**, regardless of whether you use all of it or not.
* **Best For**: Workloads with **predictable and consistent traffic patterns** where you have high utilization of your provisioned throughput. This often provides the lowest cost per RU for consistent high usage.
* **Throttling**: If your application's consumption exceeds the provisioned RU/s, requests will be throttled.

#### b. Autoscale Provisioned Throughput

* **How it Works**: You set a *maximum* RU/s (e.g., 4000 RU/s). Cosmos DB automatically and instantly scales the throughput between 10% and 100% of your configured maximum (e.g., 400 RU/s to 4000 RU/s).
* **Billing**: You are billed **hourly for the highest RU/s the system scaled to within that hour**.
* **Best For**: Workloads with **variable or unpredictable traffic patterns**. It helps avoid throttling during peak times and reduces costs during low-usage periods without manual intervention.
* **Cost Factor**: The cost per RU for autoscale is typically 1.5 times the cost of manually provisioned RUs, but the overall cost can be lower if your average utilization is less than ~66% of your peak.

#### c. Serverless

* **How it Works**: You don't provision any throughput. Instead, Cosmos DB handles capacity automatically based on your usage.
* **Billing**: You are billed **per actual Request Unit consumed** by your database operations, and for the storage consumed.
* **Best For**:
    * Workloads with **intermittent or unpredictable traffic**, where the average-to-peak traffic ratio is low.
    * Development, testing, and small applications with unpredictable bursts.
    * Scenarios where you want to pay only for what you use, without having to estimate or manage throughput.
* **Limitations**: Serverless accounts are currently limited to a single Azure region (no global distribution for the serverless tier itself, though you can use other regions for replication with provisioned throughput). There's also a maximum RU/s burst limit (e.g., typically 5,000 RU/s per container).

### 4. Monitoring RUs

You can monitor your RU consumption and identify potential bottlenecks or over-provisioning using:

* **Azure Portal Insights**: Navigate to your Cosmos DB account, then to the **Insights** blade. Here you can view metrics like:
    * **Total Request Units**: Total RUs consumed over time.
    * **Normalized RU Consumption**: Percentage of provisioned throughput being utilized (useful for identifying hot partitions or inefficient queries).
    * **Throttled Requests (429s)**: Indicates when your application is exceeding provisioned throughput.
* **Azure Monitor Metrics**: For more granular analysis, you can create custom charts in Azure Monitor to track RU usage, latency, and other performance metrics down to fine-grained intervals.
* **SDKs**: Cosmos DB SDKs provide the `RequestCharge` property in the response headers of every operation, allowing you to programmatically log and analyze the RU cost of individual requests.

### 5. Cost Implications

RUs are the primary determinant of your Cosmos DB bill. Optimizing your RU consumption is key to managing costs:

* **Right-size your throughput**: Provision enough RUs to avoid throttling, but not so much that you pay for unused capacity. Use the capacity planner and monitor actual usage.
* **Optimize queries**: Ensure queries use optimal indexing and avoid cross-partition queries where possible.
* **Optimize indexing policy**: Only index properties that you actually query on to reduce write RU cost.
* **Choose the right capacity mode**: Select provisioned (manual), autoscale, or serverless based on your workload's predictability and traffic patterns.
* **Data modeling**: Design your data model and partition keys carefully to distribute workload evenly and minimize cross-partition operations.

Understanding RUs empowers you to accurately estimate costs, provision appropriate throughput, and optimize your application's performance within Azure Cosmos DB.