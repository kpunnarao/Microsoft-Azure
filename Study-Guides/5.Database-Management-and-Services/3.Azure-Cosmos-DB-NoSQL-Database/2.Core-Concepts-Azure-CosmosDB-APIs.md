# Core Concepts (APIs: SQL, MongoDB, Cassandra, Gremlin, Table)

This multi-model approach is one of Cosmos DB's most powerful features, allowing developers to leverage the best-suited data model and query language for their specific application needs, all while benefiting from Cosmos DB's underlying global distribution and scalability.

Here's a breakdown of each core API:

### Core Concepts: Azure Cosmos DB APIs

Azure Cosmos DB's underlying data storage and indexing capabilities are highly optimized. 

The various APIs essentially provide different "views" or "protocol compatibility layers" on top of this core engine, allowing developers to interact with the data using familiar tools and paradigms.

---

### 1. API for NoSQL (formerly SQL API)

* **Data Model**: **Document Database**. Data is stored as schema-agnostic JSON documents. These documents are flexible and can contain nested objects and arrays, making them highly adaptable to evolving data structures.
* **Query Language/Interface**: **SQL-like query language (Azure Cosmos DB SQL Query API)**. This is the native query language for Cosmos DB. It's similar to traditional SQL but optimized for querying JSON documents, allowing for powerful filtering, ordering, aggregation, and JOINs across documents. It also supports JavaScript stored procedures, triggers, and User-Defined Functions (UDFs).
* **Key Compatibility/Features**: This is the **most feature-rich API** in Cosmos DB. It exposes all the capabilities of Cosmos DB, including comprehensive indexing, multiple consistency levels, multi-region writes, change feed, and more fine-grained control over Request Units (RUs). SDKs are available for .NET, Java, Node.js, Python, and Go.
* **Ideal Use Cases**:
    * New cloud-native applications requiring a flexible schema.
    * Web, mobile, gaming, and IoT applications that need very low latency, high throughput, and global distribution.
    * Applications where developers are comfortable with SQL-like queries but need NoSQL benefits.
    * Real-time analytics and personalization engines.

---

### 2. API for MongoDB

* **Data Model**: **Document Database**. Data is stored as JSON documents (or BSON, MongoDB's binary JSON format).
* **Query Language/Interface**: **MongoDB wire protocol compatible**. This means you can use existing MongoDB drivers, SDKs, and tools (like MongoDB Shell, MongoDB Compass, Mongoose) to interact with Cosmos DB as if it were a MongoDB database. It supports most of the MongoDB query language (MQL) and aggregation pipeline features.
* **Key Compatibility/Features**: Designed for seamless migration of existing MongoDB applications to Azure with minimal to no code changes. It provides the global distribution, high availability, and scalability of Cosmos DB while leveraging your existing MongoDB skillset and ecosystem.
* **Ideal Use Cases**:
    * "Lift and shift" migrations of existing MongoDB applications to a fully managed cloud service.
    * Developers already familiar with MongoDB and its ecosystem.
    * Scenarios where you want the agility of MongoDB's development model with the enterprise-grade guarantees of Azure.

---

### 3. Cassandra API

* **Data Model**: **Column-Family Database**. Data is organized into tables with rows and columns, similar to a relational database, but with a denormalized, schema-on-read approach where columns can vary per row within a table (though typically consistent within a partition key).
* **Query Language/Interface**: **Cassandra Query Language (CQL v4)**. Fully compatible with Apache Cassandra's CQL. You can use native Apache Cassandra drivers and tools.
* **Key Compatibility/Features**: Ideal for migrating existing Apache Cassandra workloads to Azure. It provides a highly available and linearly scalable solution for very large datasets, often used for time-series data or other write-heavy, denormalized workloads. It supports key features like materialized views (though specific limitations apply compared to native Cassandra).
* **Ideal Use Cases**:
    * Migrating large-scale Apache Cassandra applications.
    * IoT data ingestion and processing (e.g., sensor data).
    * Time-series data storage.
    * Archival data.

---

### 4. Gremlin API

* **Data Model**: **Graph Database**. Data is stored as a collection of vertices (nodes) and edges (relationships), where both vertices and edges can have properties.
* **Query Language/Interface**: **Apache TinkerPop Gremlin traversal language**. This is a powerful, imperative, functional query language designed for navigating and manipulating graph data.
* **Key Compatibility/Features**: Leverages the popular Apache TinkerPop framework, allowing you to use existing Gremlin drivers and tools. Cosmos DB's graph engine automatically indexes all vertex and edge properties, ensuring efficient traversal.
* **Ideal Use Cases**:
    * Social networking: Managing connections between users, friends, posts.
    * Recommendation engines: Suggesting products or content based on user interactions and relationships.
    * Fraud detection: Identifying complex patterns in financial transactions.
    * Identity and access management: Modeling user permissions and resource access.
    * Knowledge graphs and master data management.

---

### 5. Table API

* **Data Model**: **Key-Value Store / Semi-structured Table**. Data is stored as entities within tables, where each entity has a `PartitionKey`, a `RowKey`, and a set of custom properties. It's schemaless, meaning different entities in the same table can have different sets of properties.
* **Query Language/Interface**: **OData Protocol**. Compatible with the Azure Table storage service SDKs and APIs.
* **Key Compatibility/Features**: Provides a premium version of Azure Table storage. While Azure Table storage is a very cost-effective and scalable key-value store, Cosmos DB's Table API adds enterprise-grade benefits like:
    * Guaranteed single-digit millisecond latency.
    * Automatic indexing of all properties (unlike Azure Table storage where only PartitionKey and RowKey are indexed by default).
    * Global distribution with multi-region writes.
    * Higher throughput guarantees (RUs).
    * Standard consistency levels.
* **Ideal Use Cases**:
    * Migrating existing Azure Table storage applications that require higher throughput, lower latency, or global distribution capabilities.
    * Applications needing simple, fast key-value lookups with flexible schema attributes.
    * Massive scale semi-structured data where complex queries are not the primary need.

---

### Choosing the Right API:

The choice of API depends on several factors:

* **Existing Application/Skills**: If you're migrating an existing application or your team has expertise in a particular NoSQL technology (e.g., MongoDB, Cassandra), choose the corresponding API for compatibility and ease of transition.
* **Data Model & Query Needs**:
    * **JSON documents with flexible queries**: API for NoSQL (SQL API), MongoDB API.
    * **Graph relationships and traversals**: Gremlin API.
    * **Large-scale column-family data/time series**: Cassandra API.
    * **Simple key-value lookups**: Table API.
* **Required Features**: The API for NoSQL generally exposes the most comprehensive set of Cosmos DB's advanced features. If your application needs the absolute latest Cosmos DB features, the native SQL API is often the first to receive them.

This detailed look at the core APIs should provide a clear picture of their individual strengths and when to use each one.